import logging
from copy import deepcopy
import tkinter as tk
from tkinter import ttk
from idlelib.tooltip import Hovertip
import os
import tkfontchooser
from dataclasses import dataclass, field, asdict, fields
from typing import Optional, List
from pydantic import Field
from pydantic.dataclasses import dataclass as pyd_dataclass
from .util.widgets import CustomText

log = logging.getLogger(__name__)


@pyd_dataclass
class GenerationSettings:
    """GPT model settings"""

    max_new_tokens: int = Field(
        description="Maximum amount of tokens generated by the model", ge=0, le=2048
    )
    do_sample: bool = Field(title="do sample")
    temperature: float = Field(
        description="Degree of randomness from the model", ge=0, le=2, increment=0.01
    )
    top_p: float = Field(
        ge=0,
        le=1,
        increment=0.01,
        description="Pick from the tokens whose probabilities add up to top_p",
    )
    typical_p: float = Field(title="typical_p", ge=0, le=1, increment=0.01)
    repetition_penalty: float = Field(ge=1, le=1.5, increment=0.01)
    top_k: int = Field(
        ge=0, le=100, description="Pick from the first top_k tokens made by the model"
    )
    min_length: int = Field(
        ge=0, le=2048, description="minimum amount of tokens in a generation"
    )
    no_repeat_ngram_size: int = Field(description="no_repeat_ngram_size", ge=0, le=20)
    num_beams: int = Field(ge=1, le=20, description="num_beams")
    penalty_alpha: int = Field(ge=0, le=5, description="penalty_alpha")
    length_penalty: int = Field(ge=-5, le=5, description="length_penalty")
    early_stopping: bool = Field(description="early_stopping")
    add_bos_token: bool = Field(description="add_bos_token")
    truncation_length: int = Field(ge=0, le=8192, description="truncation_length")
    ban_eos_token: bool = Field(description="ban_eos_token")
    skip_special_tokens: bool = Field(description="skip_special_tokens")
    stopping_strings: List[str] = Field(description="stopping_strings")

    @classmethod
    def llama_defaults(cls):
        """Specific to how I use LLaMa models"""
        return cls(
            max_new_tokens=100,
            do_sample=True,
            temperature=0.75,
            top_p=0.73,
            typical_p=1,
            repetition_penalty=1.18,
            top_k=40,
            min_length=0,
            no_repeat_ngram_size=0,
            num_beams=1,
            penalty_alpha=0,
            length_penalty=1,
            early_stopping=False,
            add_bos_token=True,
            truncation_length=2048,
            ban_eos_token=False,
            skip_special_tokens=True,
            stopping_strings=[],
        )


@dataclass
class UISettings:
    font_name: str
    font_size: int

    @classmethod
    def defaults(cls):
        return cls("Arial", 10)


@dataclass
class Config:
    server_address: str
    debug: bool = False
    mock: bool = False
    mock_node_amount: Optional[int] = None
    generation_settings: GenerationSettings = field(
        default_factory=GenerationSettings.llama_defaults
    )
    ui_settings: UISettings = field(default_factory=UISettings.defaults)

    @classmethod
    def from_environ(cls, server_address: Optional[str] = None) -> "Config":
        self = cls(server_address or os.environ["SERVER_ADDR"])
        self.debug = bool(os.environ.get("DEBUG"))
        self.mock = bool(os.environ.get("MOCK"))
        maybe_mock_node_amount = os.environ.get("MOCK_NODE_AMOUNT")
        if maybe_mock_node_amount:
            self.mock_node_amount = int(maybe_mock_node_amount)
        return self

    @classmethod
    async def from_database(cls, db) -> "Config":
        async with db.execute("select server_address from config") as cursor:
            row = await cursor.fetchone()
        return cls(row[0])


class SettingsView:
    def __init__(self, config: Config):
        self.current_readonly_config = config
        self.view_config = deepcopy(config)

    def create_widgets(self, *args, **kwargs):
        self.toplevel = tk.Toplevel(*args, **kwargs)
        self.toplevel.title("synthnav settings")

        self.notebook = ttk.Notebook(self.toplevel)

        self.general_settings = ttk.Frame(self.notebook)
        self.create_general_settings_widgets()

        self.interface_settings = ttk.Frame(self.notebook)
        self.create_interface_settings_widgets()

        self.generation_settings = ttk.Frame(self.notebook)
        self.create_generation_settings_widgets()

        self.notebook.add(self.general_settings, text="General")
        self.notebook.add(self.interface_settings, text="Interface")
        self.notebook.add(self.generation_settings, text="Generation")
        self.notebook.pack()

        self.buttons = tk.Frame(self.toplevel)
        self.apply_button = ttk.Button(
            self.buttons, text="Apply", state="disabled", command=self.on_wanted_apply
        )
        self.apply_button.grid(row=0, column=0)

        self.cancel_button = tk.Button(
            self.buttons, text="Cancel", command=self.on_wanted_cancel
        )
        self.cancel_button.grid(row=0, column=1)
        self.buttons.pack()

    def on_wanted_cancel(self):
        self.toplevel.destroy()

    def on_wanted_apply(self):
        print("TODO")

    def on_config_change(self):

        if (
            self.view_config.server_address
            == self.current_readonly_config.server_address
        ):
            self.notebook.tab(0, text="General")
        else:
            self.notebook.tab(0, text="General*")

        print("v", self.view_config.ui_settings)
        print("c", self.current_readonly_config.ui_settings)

        if self.view_config.ui_settings == self.current_readonly_config.ui_settings:
            self.notebook.tab(1, text="Interface")
        else:
            self.notebook.tab(1, text="Interface*")

        if (
            self.view_config.generation_settings
            == self.current_readonly_config.generation_settings
        ):
            self.notebook.tab(2, text="Generation")
        else:
            self.notebook.tab(2, text="Generation*")

        if self.view_config == self.current_readonly_config:
            self.apply_button.state(["disabled"])
        else:
            self.apply_button.state(["!disabled"])

    def on_edited_general_settings_server_address(self, _event):
        new_server_address = self.server_address.get("1.0", "end").strip()
        log.debug("new addr: %r", new_server_address)
        self.view_config.server_address = new_server_address
        self.on_config_change()

    def create_general_settings_widgets(self):
        self.server_address = CustomText(
            self.general_settings,
            height=1,
            width=50,
            command=self.on_edited_general_settings_server_address,
        )
        self.server_address.insert(tk.END, self.current_readonly_config.server_address)

        key_label = tk.Label(self.general_settings, text="textgen-webui address")
        key_label.grid(row=0, column=0)
        self.server_address.grid(row=0, column=1)

    def create_interface_settings_widgets(self):
        key_label = tk.Label(self.interface_settings, text="Font")

        font_name, font_size = (
            self.view_config.ui_settings.font_name,
            self.view_config.ui_settings.font_size,
        )
        self.font_button = tk.Button(
            self.interface_settings,
            text=f"{font_name} {font_size}",
            font=(font_name, font_size),
            command=self.on_wanted_font_change,
        )

        key_label.grid(row=0, column=0)
        self.font_button.grid(row=0, column=1)

    def on_wanted_font_change(self):

        font_name, font_size = (
            self.view_config.ui_settings.font_name,
            self.view_config.ui_settings.font_size,
        )

        font = tkfontchooser.askfont(self.toplevel, family=font_name, size=font_size)
        if font:
            font_name, font_size = font["family"], font["size"]
            self.view_config.ui_settings.font_name = font_name
            self.view_config.ui_settings.font_size = font_size
            self.font_button.configure(
                text=f"{font_name} {font_size}",
                font=(font_name, font_size),
            )
            self.on_config_change()

    def on_written_generation_field(self, field_name: str, *, type):
        def handler():
            value_widget = self.key_value_widgets[field_name]
            match type:
                case "bool":
                    value = self.generation_settings.getvar(name=f"gen_{field_name}")
                case "float":
                    value = float(value_widget.get())
                case "int":
                    value = int(value_widget.get())
                case _:
                    raise AssertionError("invalid type " + repr(type))
            setattr(self.view_config.generation_settings, field_name, value)
            self.on_config_change()

        return handler

    def create_generation_settings_widgets(self):
        # TODO refactor into single loop
        self.key_value_widgets = {}
        descriptions = {}

        values = asdict(self.current_readonly_config.generation_settings)

        for field in fields(self.current_readonly_config.generation_settings):
            key = field.name
            print(key, field.default.title)
            print(field)
            field_data = field.default
            descriptions[key] = field_data.description

            if field.type == bool:
                self.key_value_widgets[key] = ttk.Checkbutton(
                    self.generation_settings,
                    variable=tk.BooleanVar(
                        self.generation_settings, name=f"gen_{key}", value=values[key]
                    ),
                    onvalue=True,
                    offvalue=False,
                    command=self.on_written_generation_field(field.name, type="bool"),
                )
            elif field.type in (int, float):
                # use Spinbox
                entry = ttk.Spinbox(
                    self.generation_settings,
                    from_=field_data.ge,
                    to=field_data.le,
                    increment=field_data.extra.get("increment", 1),
                    command=self.on_written_generation_field(
                        field.name, type=str(field.type.__name__)
                    ),
                )
                entry.set(values[key])
                self.key_value_widgets[key] = entry

        for index, key in enumerate(values.keys()):
            value_widget = self.key_value_widgets.get(key)
            if not value_widget:
                continue

            key_label = tk.Label(self.generation_settings, text=key)
            key_label.grid(row=index, column=0)
            key_tip = Hovertip(key_label, descriptions[key])
            value_widget.grid(row=index, column=1)
